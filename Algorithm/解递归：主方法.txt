主方法存在着限制，其形式必须是：
T(n) = aT(n/b) + f(n)
意思是：f(n)可分为a个f(n/b)规模的子问题，b > 1才可以保证问题规模在减少，最终才可以求出解来。

1、由f(n)构造出的树的高度是logb_n
	(n一直除以b，除到1所需要的次数就是logb_n)
2、叶子节点的数量是：a ^ logb_n，由对数性质a^logb_n = n^logb_a得出：叶子数量为n^logb_a

使用主方法需要首先比较顶层和底层的和：
顶层：f(n)
底层：n^logb_a
然后分成三种情况进行讨论：
1、顶层 > 底层：那么服从顶层，即T(n) = theta(f(n))
2、顶层 < 底层：那么服从底层，即T(n) = theta(n^logb_a)
3、顶层 = 底层：


【Merge Sort】
对于归并排序来说，其递归式子是T(n) = 2 * T(n/2) + theta(n)
其中：归并排序每次可分为两个子问题，因此a = 2；
	每个子问题的问题规模为原问题的一半，因此b=2；
	theta(n)是附加的计算量，这其中就包括了合并时的计算量（合并是线性时间）